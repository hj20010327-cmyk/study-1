<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>미니 크아 2P (학습용)</title>
  <style>
    body{margin:0;font-family:system-ui,sans-serif;background:#0b1220;color:#e5e7eb;display:flex;flex-direction:column;align-items:center;gap:10px;padding:14px}
    .hud{max-width:880px;width:100%;display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between}
    .badge{background:#111a2e;border:1px solid #243255;border-radius:999px;padding:6px 10px;font-size:14px}
    .wrap{display:flex;gap:14px;flex-wrap:wrap;justify-content:center}
    canvas{background:#08101e;border:1px solid #22314f;border-radius:12px}
    .help{max-width:880px;opacity:.85;font-size:14px;line-height:1.5}
    .p1{color:#fbbf24}
    .p2{color:#34d399}
  </style>
</head>
<body>
  <div class="hud">
    <div class="badge">
      <span class="p1">1P</span> 이동: 방향키 · 폭탄: Space /
      <span class="p2">2P</span> 이동: WASD · 폭탄: Shift · 리셋: R
    </div>
    <div class="badge">
      남은 박스: <span id="boxes">0</span> ·
      <span class="p1">1P 점수</span>: <span id="s1">0</span> ·
      <span class="p2">2P 점수</span>: <span id="s2">0</span>
    </div>
  </div>

  <div class="wrap">
    <canvas id="game" width="780" height="480"></canvas>
  </div>

  <div class="help">
    - 회색 = 벽(불가) / 갈색 = 박스(파괴) / 파랑 = 물풍선 / 하늘색 = 물줄기<br>
    - 폭발에 닿으면 해당 플레이어 리스폰(학습용) · 박스 파괴 +10(폭탄 주인) · 상대 맞추면 +50
  </div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  const boxesEl = document.getElementById('boxes');
  const s1El = document.getElementById('s1');
  const s2El = document.getElementById('s2');

  const TILE = 30;
  const COLS = Math.floor(canvas.width / TILE);   // 26
  const ROWS = Math.floor(canvas.height / TILE);  // 16

  const T = { EMPTY: 0, WALL: 1, BOX: 2 };

  // 두 플레이어
  const p1 = {
    id: 1, x: 1, y: 1, spawnX: 1, spawnY: 1,
    bombPower: 2, bombLimit: 1,
    moveCooldown: 0,
    color: "#fbbf24"
  };
  const p2 = {
    id: 2, x: COLS-2, y: ROWS-2, spawnX: COLS-2, spawnY: ROWS-2,
    bombPower: 2, bombLimit: 1,
    moveCooldown: 0,
    color: "#34d399"
  };

  let score1 = 0, score2 = 0;

  // bomb: {x,y,explodeAt,ownerId,power}
  let bombs = [];
  // flame: {x,y,endsAt,ownerId}
  let flames = [];
  let map = [];

  const keys = new Set();
  window.addEventListener('keydown', (e) => {
    const k = e.key.toLowerCase();
    keys.add(k);

    if (!e.repeat) {
      if (k === ' ') { e.preventDefault(); placeBomb(p1); }
      if (k === 'shift') { placeBomb(p2); }
      if (k === 'r') resetGame();
    }
  });
  window.addEventListener('keyup', (e) => keys.delete(e.key.toLowerCase()));

  function updateHUD() {
    let boxCount = 0;
    for (let y=0; y<ROWS; y++) for (let x=0; x<COLS; x++) if (map[y][x] === T.BOX) boxCount++;
    boxesEl.textContent = boxCount;
    s1El.textContent = score1;
    s2El.textContent = score2;
  }

  function buildMap() {
    map = Array.from({length: ROWS}, () => Array(COLS).fill(T.EMPTY));

    // 테두리 벽
    for (let y = 0; y < ROWS; y++) {
      for (let x = 0; x < COLS; x++) {
        if (x === 0 || y === 0 || x === COLS-1 || y === ROWS-1) map[y][x] = T.WALL;
      }
    }

    // 격자 벽
    for (let y = 2; y < ROWS-2; y += 2) {
      for (let x = 2; x < COLS-2; x += 2) {
        map[y][x] = T.WALL;
      }
    }

    // 박스 랜덤 배치 (양쪽 스폰 구역 비우기)
    for (let y = 1; y < ROWS-1; y++) {
      for (let x = 1; x < COLS-1; x++) {
        if (map[y][x] !== T.EMPTY) continue;

        const safe1 = (x <= 2 && y <= 2);
        const safe2 = (x >= COLS-3 && y >= ROWS-3);
        if (safe1 || safe2) continue;

        if (Math.random() < 0.42) map[y][x] = T.BOX;
      }
    }

    // 플레이어 위치 초기화
    p1.x = p1.spawnX; p1.y = p1.spawnY;
    p2.x = p2.spawnX; p2.y = p2.spawnY;

    bombs = [];
    flames = [];
    updateHUD();
  }

  function bombCountByOwner(ownerId) {
    let c = 0;
    for (const b of bombs) if (b.ownerId === ownerId) c++;
    return c;
  }

  function placeBomb(p) {
    if (bombCountByOwner(p.id) >= p.bombLimit) return;
    if (bombs.some(b => b.x === p.x && b.y === p.y)) return;
    if (map[p.y][p.x] !== T.EMPTY) return;

    const now = performance.now();
    bombs.push({
      x: p.x, y: p.y,
      explodeAt: now + 1600,
      ownerId: p.id,
      power: p.bombPower
    });
  }

  function addFlame(x,y,ownerId) {
    const now = performance.now();
    const existing = flames.find(f => f.x===x && f.y===y);
    if (existing) {
      existing.endsAt = Math.max(existing.endsAt, now + 450);
    } else {
      flames.push({x, y, endsAt: now + 450, ownerId});
    }
  }

  function explodeBomb(bomb) {
    addFlame(bomb.x, bomb.y, bomb.ownerId);

    const dirs = [
      {dx:1, dy:0},
      {dx:-1, dy:0},
      {dx:0, dy:1},
      {dx:0, dy:-1},
    ];

    for (const {dx, dy} of dirs) {
      for (let step=1; step<=bomb.power; step++) {
        const x = bomb.x + dx*step;
        const y = bomb.y + dy*step;

        if (map[y][x] === T.WALL) break;

        if (map[y][x] === T.BOX) {
          addFlame(x,y,bomb.ownerId);
          map[y][x] = T.EMPTY;
          if (bomb.ownerId === 1) score1 += 10; else score2 += 10;
          updateHUD();
          break;
        }

        addFlame(x,y,bomb.ownerId);

        // 연쇄 폭발
        const idx = bombs.findIndex(b => b.x === x && b.y === y);
        if (idx !== -1) {
          const chained = bombs.splice(idx, 1)[0];
          explodeBomb(chained);
          break;
        }
      }
    }
  }

  function isBombAt(x,y) {
    return bombs.some(b => b.x === x && b.y === y);
  }

  function tileBlocked(x,y) {
    if (x < 0 || y < 0 || x >= COLS || y >= ROWS) return true;
    if (map[y][x] === T.WALL || map[y][x] === T.BOX) return true;
    return false;
  }

  function handleMove(p, dt) {
    p.moveCooldown -= dt;
    if (p.moveCooldown > 0) return;

    let dx = 0, dy = 0;
    if (p.id === 1) {
      if (keys.has('arrowleft')) dx = -1;
      else if (keys.has('arrowright')) dx = 1;
      else if (keys.has('arrowup')) dy = -1;
      else if (keys.has('arrowdown')) dy = 1;
    } else {
      if (keys.has('a')) dx = -1;
      else if (keys.has('d')) dx = 1;
      else if (keys.has('w')) dy = -1;
      else if (keys.has('s')) dy = 1;
    }

    if (dx === 0 && dy === 0) return;

    const nx = p.x + dx;
    const ny = p.y + dy;

    // 벽/박스
    if (tileBlocked(nx, ny)) return;

    // 상대 플레이어 칸으로 이동 금지
    const other = (p.id === 1) ? p2 : p1;
    if (other.x === nx && other.y === ny) return;

    // 폭탄은 원칙적으로 통과 불가
    // 단, "내가 폭탄 위에 서 있는 상태"에서 빠져나가는 건 허용(다음칸에 폭탄이 없을 때)
    const standingOnBomb = isBombAt(p.x, p.y);
    const bombInNext = isBombAt(nx, ny);
    if (bombInNext) return;

    // 이동
    p.x = nx; p.y = ny;
    p.moveCooldown = 0.09;
  }

  function flameAt(x,y) {
    return flames.find(f => f.x === x && f.y === y);
  }

  function respawnPlayer(p, killedByOwnerId) {
    // 상대 점수 +50 (자기 폭탄에 죽으면 가점 없음)
    if (killedByOwnerId && killedByOwnerId !== p.id) {
      if (killedByOwnerId === 1) score1 += 50;
      else score2 += 50;
    }

    // 리스폰
    p.x = p.spawnX; p.y = p.spawnY;
    updateHUD();
  }

  // ===== 루프 =====
  let last = performance.now();
  function loop(ts) {
    const dt = Math.min(0.033, (ts - last) / 1000);
    last = ts;

    handleMove(p1, dt);
    handleMove(p2, dt);

    const now = performance.now();

    // 폭탄 폭발
    for (let i=bombs.length-1; i>=0; i--) {
      if (now >= bombs[i].explodeAt) {
        const b = bombs.splice(i, 1)[0];
        explodeBomb(b);
      }
    }

    // 불 제거
    for (let i=flames.length-1; i>=0; i--) {
      if (now >= flames[i].endsAt) flames.splice(i, 1);
    }

    // 피격 판정
    const f1 = flameAt(p1.x, p1.y);
    if (f1) respawnPlayer(p1, f1.ownerId);

    const f2 = flameAt(p2.x, p2.y);
    if (f2) respawnPlayer(p2, f2.ownerId);

    draw();
    requestAnimationFrame(loop);
  }

  function resetGame() {
    score1 = 0; score2 = 0;
    buildMap();
  }

  // ===== 렌더 =====
  function draw() {
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // 타일
    for (let y=0; y<ROWS; y++) {
      for (let x=0; x<COLS; x++) {
        const px = x*TILE, py = y*TILE;

        ctx.fillStyle = ((x+y)%2===0) ? "#0b1731" : "#0a142b";
        ctx.fillRect(px,py,TILE,TILE);

        if (map[y][x] === T.WALL) {
          ctx.fillStyle = "#3b4252";
          ctx.fillRect(px+2,py+2,TILE-4,TILE-4);
        } else if (map[y][x] === T.BOX) {
          ctx.fillStyle = "#8b5a2b";
          ctx.fillRect(px+3,py+3,TILE-6,TILE-6);
          ctx.fillStyle = "rgba(255,255,255,0.12)";
          ctx.fillRect(px+6,py+6,TILE-12,6);
        }
      }
    }

    // 폭탄
    for (const b of bombs) {
      const cx = b.x*TILE + TILE/2;
      const cy = b.y*TILE + TILE/2;
      ctx.beginPath();
      ctx.fillStyle = "#2d6cdf";
      ctx.arc(cx, cy, TILE*0.33, 0, Math.PI*2);
      ctx.fill();

      // 주인 표시 점(1P/2P)
      ctx.beginPath();
      ctx.fillStyle = (b.ownerId === 1) ? "#fbbf24" : "#34d399";
      ctx.arc(cx, cy - 10, 4, 0, Math.PI*2);
      ctx.fill();
    }

    // 불꽃(물줄기)
    for (const f of flames) {
      const px = f.x*TILE, py = f.y*TILE;
      ctx.fillStyle = "rgba(125, 211, 252, 0.85)";
      ctx.fillRect(px+4, py+4, TILE-8, TILE-8);
      ctx.fillStyle = "rgba(255,255,255,0.25)";
      ctx.fillRect(px+8, py+8, TILE-16, 6);
    }

    // 플레이어 그리기
    drawPlayer(p1);
    drawPlayer(p2);

    // UI 오버레이
    // ctx.fillStyle = "rgba(255,255,255,0.16)";
    // ctx.fillRect(8, 8, 320, 54);
    // ctx.fillStyle = "#e5e7eb";
    // ctx.font = "14px system-ui";
    // ctx.fillText("1P: 방향키 + Space / 2P: WASD + Shift", 16, 30);
    // ctx.fillText("박스 +10(주인) / 상대 맞추면 +50", 16, 50);
  }

  function drawPlayer(p) {
    const cx = p.x*TILE + TILE/2;
    const cy = p.y*TILE + TILE/2;
    ctx.beginPath();
    ctx.fillStyle = p.color;
    ctx.arc(cx, cy, TILE*0.34, 0, Math.PI*2);
    ctx.fill();

    // 눈
    ctx.beginPath();
    ctx.fillStyle = "#111827";
    ctx.arc(cx-6, cy-5, 3, 0, Math.PI*2);
    ctx.arc(cx+6, cy-5, 3, 0, Math.PI*2);
    ctx.fill();
  }

  // 시작
  buildMap();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>